## 자바스크립트와 브라우저, 그리고 DOM (스터디 자료)

### 브라우저 환경과 다양한 명세서: 자바스크립트의 플랫폼

자바스크립트 코드는 단순히 실행되는 것이 아니라, **브라우저**라는 특정 환경에서 돌아간다. 이 환경은 크게 두 가지 표준으로 구성된다.

1.  **ECMAScript (ES)**: 자바스크립트 언어의 **문법과 코어 기능**을 정의하는 명세. `for`, `if`, `const`, `function` 등 우리가 아는 기본적인 문법이 모두 여기에 속한다.
2.  **Web API**: 브라우저가 자바스크립트에게 제공하는 **추가 기능들**. DOM, AJAX (`fetch`), `setTimeout`, Geolocation 등이 모두 Web API에 속한다. `console.log` 또한 Web API 중 하나.

현업에서 중요한 건 **`setTimeout`, `fetch` 같은 비동기 Web API가 어떻게 동작하는지**를 아는 것. 이들은 **자바스크립트 엔진** 외부에서 작동하며, 완료되면 **이벤트 루프**를 통해 콜백 함수를 다시 자바스크립트 엔진의 **콜 스택**으로 보낸다.

-----

### DOM 트리: HTML에 생명 불어넣기

브라우저는 HTML 문서를 읽어 들인 후, 이를 **트리 형태의 객체 구조**로 변환한다. 이것이 바로 **DOM (Document Object Model)**. 모든 HTML 태그는 `Element` 노드, 텍스트는 `Text` 노드, 주석은 `Comment` 노드가 된다. DOM은 단순히 HTML의 복사본이 아니라, 자바스크립트가 HTML의 구조, 내용, 스타일을 동적으로 변경할 수 있게 해주는 **인터페이스**다.

-----

### DOM 탐색하기: 목적에 맞는 효율적인 검색

요소를 찾는 다양한 방법들이 있으며, 각각의 특징을 정확히 알아야 합니다.

---

#### 기본 탐색 메서드: `getElement*`, `querySelector*`

* **`getElementById`, `getElementsByClassName`, `getElementsByTagName`**:
    * **장점**: 매우 빠릅니다. 특히 `getElementById`는 특정 `id` 하나를 바로 찾아오기 때문에 가장 효율적입니다.
    * **단점**: `getElementsBy...` 계열은 **`HTMLCollection`**이라는 **실시간(live) 컬렉션**을 반환합니다. 이 컬렉션은 DOM에 변화가 생기면 자동으로 업데이트되므로, `for` 루프를 돌며 요소를 삭제하는 경우 인덱스 오류를 유발할 수 있습니다.
* **`querySelector`, `querySelectorAll`**:
    * **장점**: CSS 선택자를 그대로 사용해 매우 유연하고 직관적입니다.
    * **단점**: 상대적으로 느릴 수 있습니다.
    * **중요**: **`NodeList`**라는 **정적(static) 컬렉션**을 반환합니다. DOM이 변경되어도 `NodeList`는 업데이트되지 않아 안전하게 순회할 수 있습니다. `NodeList`는 `forEach` 메서드를 지원하지만 `HTMLCollection`은 지원하지 않습니다.

---

#### 관계 기반 탐색 메서드: `matches`, `closest`

이 메서드들은 단순히 요소를 찾는 것을 넘어, 특정 요소와 다른 요소의 관계를 파악하는 데 유용합니다.

* **`element.matches(selector)`**:
    * **설명**: 특정 요소가 주어진 CSS 선택자에 의해 선택될 수 있는지 여부를 `true` 또는 `false`로 반환합니다. 이 메서드는 요소가 실제로 DOM에 존재해야만 작동하는 것이 아니라, 요소 자체의 속성만으로 선택자 매칭 여부를 판단합니다.
    * **활용**: `if (event.target.matches('.my-class'))`와 같이 이벤트가 발생한 요소가 특정 클래스를 가지고 있는지 확인할 때 유용합니다.
* **`element.closest(selector)`**:
    * **설명**: 해당 요소로부터 시작해 DOM 트리의 부모 방향으로 거슬러 올라가며, 주어진 CSS 선택자와 일치하는 **가장 가까운 조상 요소**를 찾습니다. 일치하는 요소를 찾지 못하면 `null`을 반환합니다.
    * **활용**: 자식 요소에 이벤트 리스너를 등록하고, 실제 이벤트 처리는 공통 부모에서 하고 싶을 때 유용합니다.  예를 들어, 테이블의 `<td>`를 클릭했지만, 이벤트 리스너는 `<table>`에 등록되어 있을 때 `event.target.closest('tr')`을 사용해 클릭된 셀이 속한 행(`<tr>`)을 쉽게 찾을 수 있습니다.
-----

### 주요 노드 프로퍼티: 노드의 정체성 확인

모든 DOM 노드는 `nodeType`, `nodeName`, `nodeValue`라는 핵심 프로퍼티를 가진다. 이를 통해 노드의 종류를 파악할 수 있다.

  * `nodeType`: 노드의 종류를 나타내는 숫자.
      * `1`: `Element` 노드 (`<p>`, `<div>` 등)
      * `3`: `Text` 노드
      * `8`: `Comment` 노드
  * `nodeName`: 노드의 이름. `p` 요소는 `"P"`, `div` 요소는 `"DIV"`로 반환된다.
  * `nodeValue`: `Text` 노드의 내용. 요소 노드는 `null`을 반환한다.

**`textContent`와 `innerText`의 미묘한 차이**:
`textContent`는 해당 노드와 그 자손 노드의 모든 **텍스트 콘텐츠**를 가져온다. HTML에 작성된 줄바꿈, 공백 등도 모두 포함된다. 반면, `innerText`는 **렌더링된 화면에 보이는 텍스트**만 반환한다. 예를 들어, CSS로 `display: none`이 적용된 요소의 텍스트는 `innerText`로 가져올 수 없다. `innerText`는 레이아웃 엔진을 거치기 때문에 `textContent`보다 성능이 떨어진다.

-----

### `innerHTML`과 `outerHTML`의 차이

`innerHTML`과 `outerHTML`은 모두 HTML 코드를 다루는 프로퍼티지만, 그 범위에 차이가 있다.

  * **`innerHTML`**: 요소 **내부의** HTML 마크업을 가져오거나 설정한다. 즉, 해당 요소의 **여는 태그와 닫는 태그 사이의 모든 콘텐츠**를 대상으로 한다.

    ```html
    <div id="container">
      <p>Hello, World!</p>
    </div>
    ```

    `document.getElementById('container').innerHTML`을 실행하면 `<p>Hello, World!</p>`가 반환된다.

  * **`outerHTML`**: 요소 **자신을 포함한** 전체 HTML 마크업을 가져오거나 설정한다. 즉, 해당 요소의 **여는 태그와 닫는 태그, 그리고 그 사이의 모든 콘텐츠**를 대상으로 한다. 이 프로퍼티에 값을 할당하면 기존 요소 자체가 교체된다.

    `document.getElementById('container').outerHTML`을 실행하면 `<div id="container"><p>Hello, World!</p></div>`가 반환된다.

    `document.getElementById('container').outerHTML = '<section id="new-container">New Content</section>';`를 실행하면 `<div id="container">` 요소가 통째로 `<section id="new-container">`로 바뀐다.

-----

### 속성과 프로퍼티: HTML과 JS의 연결

DOM 요소는 \*\*속성(attribute)\*\*과 \*\*프로퍼티(property)\*\*라는 두 가지 개념을 갖는다.

  * **속성**: HTML 태그에 직접 정의된 **초기값**. `id`, `class`, `href`, `value` 등이 속성이다. 이들은 HTML 소스 코드에 저장되며, `element.getAttribute()`와 `element.setAttribute()`로 접근한다.
  * **프로퍼티**: 자바스크립트 DOM 객체의 **현재 상태 값**. `element.id`, `element.className`, `element.href`, `element.value` 등.
  * **핵심 차이**: 속성은 변하지 않는 **초기 상태**를 나타내지만, 프로퍼티는 사용자의 상호작용에 따라 변하는 **현재 상태**를 나타낸다. 예를 들어 `<input value="123">`에서 `input.getAttribute('value')`는 항상 `"123"`이지만, `input.value`는 사용자가 입력한 값으로 변한다.

-----

### 문서 수정하기: 성능을 고려한 DOM 조작

대량의 DOM 요소를 추가하거나 삭제할 때 성능 최적화가 중요하다.

  * `innerHTML` / `outerHTML`: 문자열을 통째로 삽입하거나 교체한다. 빠르지만, **XSS 공격**에 취약할 수 있고 기존 요소에 부착된 이벤트 리스너가 모두 사라진다.
  * `createElement` + `appendChild` / `insertBefore` 등: 개별 노드를 만들어 붙이는 방식. 안전하지만, 반복문 내에서 이 작업을 수행하면 DOM에 매번 변화가 생겨 **리플로우와 리페인트**가 자주 발생해 성능이 저하될 수 있다.
  * **성능 최적화 기법**:
      * **`DocumentFragment`**: 보이지 않는 **메모리상의 가상 DOM**이다. 여러 요소를 `DocumentFragment`에 추가한 후, 마지막에 이 `DocumentFragment`를 실제 DOM에 한 번만 `appendChild`하면 **단 한 번의 리플로우**만 발생해 성능을 크게 개선할 수 있다.

-----

### 스타일과 클래스: CSS와 JS의 관심사 분리

* **`element.style`**: 인라인 스타일을 직접 조작합니다. 예: `element.style.color = 'red'`. 여러 속성을 바꿀 때는 `element.style.cssText = 'color: red; font-size: 16px;'`를 사용하면 한 번에 작성 가능합니다. 이 방식은 DOM에 직접 스타일을 추가하기 때문에 브라우저가 매번 **스타일 재계산(Recalculate Style)**을 하고, 경우에 따라 **레이아웃을 다시 배치(Reflow)**하는 비효율적인 과정을 거칠 수 있습니다. 이는 DOM 조작이 성능에 미치는 영향인 **리플로우**와 **리페인트**를 자주 유발합니다.

* **`element.classList`**: 클래스를 추가, 제거, 토글하는 메서드를 제공합니다. 예: `element.classList.add('active')`. 이 방식은 클래스 이름만 변경하고, 스타일 관련 처리는 CSS에 맡깁니다. 따라서 브라우저는 기존에 정의된 CSS 규칙을 한 번만 적용하면 되므로 훨씬 효율적입니다. **JS는 상태(state)를 제어하고, CSS는 그 상태에 따른 스타일을 담당**하는 것이 좋은 설계입니다. 이처럼 관심사를 분리하면 코드의 유지보수성이 높아질 뿐만 아니라, 성능 면에서도 이점을 얻을 수 있습니다. 


-----

### 요소 사이즈와 스크롤: 레이아웃 정보 얻기

  * **요소의 크기**:
      * `clientWidth` / `clientHeight`: 콘텐츠 영역 + **패딩**의 크기. **보더, 스크롤바는 제외**.
      * `offsetWidth` / `offsetHeight`: 콘텐츠 영역 + 패딩 + **보더 + 스크롤바**의 크기.
  * **스크롤**: `scrollWidth`, `scrollHeight`, `scrollTop`, `scrollLeft`.
      * 무한 스크롤 구현 시, `element.scrollTop + element.clientHeight >= element.scrollHeight` 조건으로 스크롤이 끝에 도달했는지 판별할 수 있다.

-----

### 브라우저 창 사이즈와 스크롤: 뷰포트와의 상호작용

  * `window.innerWidth`, `window.innerHeight`: **스크롤바를 포함한** 뷰포트의 크기.
  * `document.documentElement.clientWidth` / `clientHeight`: **스크롤바를 제외한** 뷰포트의 크기.
  * `window.scrollX`, `window.scrollY`: 현재 뷰포트의 **스크롤 위치**를 반환. `document.documentElement.scrollTop / scrollLeft`와 유사하지만 더 범용적으로 사용된다.

-----

### 좌표: 위치 기반 인터랙션 구현

  * **`element.getBoundingClientRect()`**: 해당 요소의 **뷰포트 상대적인** 위치와 크기 정보를 반환하는 메서드. `top`, `left`, `right`, `bottom`, `width`, `height` 속성을 가진다. 스크롤이 되더라도 뷰포트 기준 좌표는 변하지 않아 툴팁 위치 지정, 드래그 앤 드롭 구현에 필수적이다.
  * **`event.pageX` / `event.pageY`**: \*\*문서 전체(document)\*\*를 기준으로 한 마우스 이벤트의 좌표. 스크롤 위치를 포함하므로, 화면 상단에서 아래로 길게 이어진 문서의 경우 스크롤을 내리면 값이 계속 커진다.
  * **`event.clientX` / `event.clientY`**: **뷰포트 기준** 마우스 이벤트의 좌표. 스크롤을 내려도 뷰포트 상에서의 위치는 변하지 않으므로 값이 고정된다.

-----

### 테이블 요소 탐색: 표 내 셀 이동

HTML 테이블의 셀(`<td>`)과 행(`<tr>`)을 자바스크립트로 탐색하는 것은 흔히 발생하는 작업이다. 셀 객체는 부모/자식 관계 외에 **같은 행의 다른 셀**이나 **같은 열의 다른 셀**을 탐색하는 데 유용한 프로퍼티들을 제공한다.

  * **`cellIndex`**: 해당 셀이 속한 행에서 몇 번째 셀인지 인덱스를 반환한다.
  * **`rowIndex`**: 해당 행이 테이블에서 몇 번째 행인지 인덱스를 반환한다.
  * **`rows`**: `<table>` 요소의 프로퍼티로, 테이블 내 모든 `<tr>` 요소를 담고 있는 `HTMLCollection`을 반환한다. `table.rows[rowIndex]`와 같이 특정 행에 접근할 수 있다.
  * **`cells`**: `<tr>` 요소의 프로퍼티로, 해당 행 내 모든 `<td>` 또는 `<th>` 요소를 담고 있는 `HTMLCollection`을 반환한다. `row.cells[cellIndex]`와 같이 특정 셀에 접근할 수 있다.


## 브라우저 이벤트

브라우저 이벤트는 사용자의 행동(클릭, 키 입력)이나 브라우저의 변화(페이지 로딩, 창 크기 변경)에 반응해서 발생하는 사건이다. 자바스크립트는 이 이벤트들을 감지하고 처리하여 웹페이지를 동적으로 만든다.

---

### 브라우저 이벤트 종류와 쓰임새

브라우저 이벤트는 크게 **마우스, 키보드, 폼 이벤트**로 나눌 수 있다. 각각의 쓰임새와 활용 사례가 다르다.

#### 마우스 이벤트

사용자의 마우스 클릭이나 움직임에 반응하는 이벤트다.

* **`click`**: 요소 위에서 마우스를 눌렀다 떼는 순간 발생한다. 가장 흔한 이벤트로, **버튼 클릭, 링크 활성화, 메뉴 아이템 선택**과 같은 기본적인 사용자 인터랙션에 사용된다.
* **`dblclick`**: 요소를 빠르게 두 번 클릭했을 때 발생한다. 텍스트를 더블클릭해서 단락 전체를 선택하거나, 파일 아이콘을 더블클릭해서 실행하는 기능에 사용된다.
* **`mousedown`, `mouseup`**: 마우스 버튼을 누르는 순간(`mousedown`)과 떼는 순간(`mouseup`)에 각각 발생한다. 이 두 이벤트를 조합해 **드래그 앤 드롭 기능의 시작과 끝**을 감지하거나, 특정 요소를 마우스로 조작하는 데 활용된다.
* **`mousemove`**: 마우스 포인터가 요소 위에서 움직일 때 지속적으로 발생한다. **마우스 커서를 따라 움직이는 툴팁**이나, 마우스 위치를 추적해 그림을 그리는 기능 등에 활용된다.
* **`mouseover`, `mouseout`**: 마우스 포인터가 요소 위로 올라올 때(`mouseover`)와 벗어날 때(`mouseout`) 발생한다. 요소에 마우스를 올리면 스타일이 바뀌는 **호버(hover) 효과**를 자바스크립트로 구현할 때 사용된다.

#### 키보드 이벤트

키보드 입력에 반응하는 이벤트다.

* **`keydown`**: 키를 누르는 순간 발생하며, 키를 길게 누르면 이벤트가 반복적으로 발생한다. **게임에서 캐릭터를 연속적으로 이동**시키거나, 실시간으로 키 입력 이벤트를 감지해야 하는 기능에 쓰인다.
* **`keyup`**: 키를 눌렀다 떼는 순간 발생한다. `keydown`과 달리 한 번만 발생하므로, 사용자가 입력 필드에 입력을 마쳤을 때 **유효성 검사**를 수행하는 데 적합하다.
* **`keypress`**: 키를 누르는 순간 발생하며, 주로 **문자 키 입력**에만 반응한다. (`keydown`과 `keyup`이 더 범용적이어서 최근에는 `keypress`의 사용 빈도가 낮아지고 있다.)

#### 폼 이벤트

폼 요소의 상태 변화에 반응하는 이벤트다.

* **`submit`**: `<form>`이 제출될 때 발생한다. `event.preventDefault()`를 이용해 페이지 이동을 막고 **폼 유효성 검사** 로직을 추가하는 데 사용된다.
* **`focus`**: 사용자가 입력 필드(`input`, `textarea`)를 클릭하여 포커스를 맞출 때 발생한다. **포커스 시 입력 필드 주변에 하이라이트**를 표시하거나, 입력 가이드 메시지를 보여주는 기능에 활용된다.
* **`blur`**: 포커스를 잃을 때 발생한다. 사용자가 입력 필드에서 벗어나는 순간에 **입력값의 유효성 검사**를 수행하는 데 유용하다.
* **`change`**: 입력 필드(`select`, `checkbox`, `radio`)의 값이 변경되고, 포커스를 잃었을 때 발생한다. **셀렉트 박스의 옵션이 변경**되거나, 체크박스 상태가 바뀔 때 특정 동작을 실행하는 데 사용된다.
* **`input`**: 입력 필드의 값이 **변경될 때마다 실시간으로** 발생한다. 사용자가 입력하는 즉시 **검색 결과를 필터링**하거나, 글자 수 제한을 표시하는 기능에 적합하다.

---

### 버블링과 캡처링: 이벤트 전파의 두 가지 흐름

이벤트가 발생하면 DOM 트리를 따라 전파되는데, 이때 **캡처링**과 **버블링** 두 단계를 거친다.

- **캡처링 단계**: `window` 객체부터 시작해 이벤트가 발생한 요소까지 아래로 내려오는 과정이다. 
- **버블링 단계**: 이벤트가 발생한 요소에서 시작해 `window` 객체까지 위로 올라가는 과정이다. 대부분의 이벤트 리스너는 이 단계에서 동작하도록 설정돼 있다.

`addEventListener`의 세 번째 인자로 `true`를 명시하면 캡처링 단계에서, `false`(기본값)를 사용하면 버블링 단계에서 이벤트를 처리한다. `event.stopPropagation()`은 이 전파 과정을 특정 지점에서 멈추는 역할을 한다.

---

### 이벤트 위임 (Event Delegation): 효율적인 이벤트 관리

이벤트 위임은 여러 자식 요소에 개별적으로 이벤트 리스너를 등록하는 대신, **단 하나의 부모 요소에 리스너를 등록**하고 자식 요소의 이벤트를 처리하는 기법이다. 

* **원리**: **이벤트 버블링**을 활용해 부모 요소에서 `event.target`을 통해 실제 이벤트가 발생한 자식 요소를 식별한다.
* **장점**:
    - **메모리 효율성**: 수많은 요소에 리스너를 추가하는 대신 하나만 등록해 메모리 사용량을 줄인다.
    - **동적 요소 처리**: 나중에 추가되거나 제거되는 요소에 대해 별도의 리스너를 추가할 필요가 없어 코드 유지보수성이 높아진다.

---

### 브라우저 기본 동작: 막거나, 방해하지 않거나

모든 이벤트에는 브라우저가 기본적으로 수행하는 동작이 있다. `<a>` 태그 클릭 시 페이지 이동, `<form>` 제출 시 페이지 새로고침 등.

* **`event.preventDefault()`**: 이러한 기본 동작을 막을 때 사용된다. 폼 유효성 검사 실패 시 제출을 막는 등의 용도로 활용된다.
* **`passive: true`**: `addEventListener`의 옵션으로, 스크롤과 같은 성능 민감 이벤트에서 `preventDefault()`가 호출되지 않을 것임을 브라우저에 알려준다. 브라우저가 이벤트 리스너를 기다리지 않고 즉시 스크롤을 시작해 **버벅거림(jank)**을 방지한다.

---

### 커스텀 이벤트 디스패치: 새로운 이벤트 생성

브라우저가 제공하는 기본 이벤트 외에, 개발자가 직접 정의하고 발생시키는 **커스텀 이벤트**를 만들 수 있다.

* **`new CustomEvent(eventName, options)`**: 새로운 커스텀 이벤트 객체를 생성한다. `options`의 `detail` 속성을 이용해 원하는 데이터를 이벤트와 함께 전달할 수 있다.
* **`element.dispatchEvent(event)`**: 생성한 이벤트 객체를 특정 요소에 전달해 발생시킨다.

**활용**: 컴포넌트 간 통신. 부모 컴포넌트가 자식 컴포넌트의 특정 변화를 감지하고 싶을 때, 자식 컴포넌트가 커스텀 이벤트를 발생시키면 부모 컴포넌트에서 이를 리스닝하여 처리할 수 있다.

---
